# Сортировка слиянием (merge sort)

### Временная сложность
`O(nlogn)` в худшем, среднем и лучшем случае, где `n` — количество элементов в массиве
- Алгоритм делит массив пополам на каждом уровне рекурсии, что дает логарифмическую составляющую `logn`.
- На каждом уровне рекурсии происходит слияние `n` элементов, что дает линейную составляющую `n`.

### Пространственная сложность
`O(n)`, так как для слияния двух подмассивов требуется временный массив того же размера, что и исходный массив. 

### Идея
Сортировка слиянием является примером алгоритма "разделяй и властвуй":
- Разбиваем массив на подмассивы до тех пор, пока каждый подмассив не будет состоять из одного элемента (или будет пустым). 
- Рекурсивно сливаем подмассивы вместе таким образом, чтобы они были отсортированы. 

### Функция merge_sort
1. Создаётся новый массив `res`, размер которого равен сумме размеров двух входных массивов `a` и `b`.
2. Два индекса `idxA` и `idxB` инициализируются нулями. Они будут использоваться для итерации по элементам массивов `a` и `b` соответственно.
3. В цикле `for`, который продолжается до тех пор, пока сумма `idxA` и `idxB` меньше суммы длин `lenA` и `lenB`, проверяем следующее составное условие:
- если `idxB` равен `lenB` -> все элементы в массиве `b` уже добавлены в результат, или
- если текущий элемент в массиве `a` меньше текущего элемента в массиве `b` и `idxA` меньше `lenA` -> есть оставшиеся элементы в `a` для сравнения) 
4. Если условие из шага 3 выполняется, то следующий элемент из `a` добавляется в `res` и `idxA` увеличивается на `1`.
5. В противном случае, следующий элемент из `b` добавляется в `res` и `idxB` увеличивается на `1`.
Когда цикл завершается, все элементы из обоих массивов `a` и `b` слиты в `res` в отсортированном порядке, и функция возвращает `res`.

### Функция sort
1. Проверяет, если массив содержит ноль или один элемент, он уже отсортирован, и возвращает его.
2. Находит середину массива и разделяет его на два подмассива: `left` и `right`.
3. Рекурсивно вызывает сама себя для сортировки этих подмассивов.
4. Использует функцию `mergeSort` для слияния отсортированных подмассивов в один отсортированный массив.

### Польза такой сортировки
Сортировка слиянием используется не только для упорядочивания элементов, но и как строительный блок в более сложных алгоритмах и системах.
1. **Сортировка больших объемов данных**: Так как временная сложность постоянна `O(nlogn)`, merge sort хорошо подходит для сортировки больших объемов данных, 
особенно когда данные не помещаются в память и требуются алгоритмы сортировки на внешних носителях (external sorting).
2. **Сортировка связанных списков**: merge sort часто используется для сортировки связанных списков, так как не требует доп. затрат памяти для перемещения элементов, как в случае с массивами.
3. **Обработка данных в многопоточных и распределенных системах**: Сортировка слиянием адаптируется к параллельной обработке, 
позволяя выполнять сортировку подмассивов в разных потоках или на разных узлах в распределенной системе, а затем сливать результаты. (MapReduce и другие распределенные вычислительные модели.)
4. **Стабильная сортировка**: В отличие от, например, быстрой сортировки сортировка слиянием стабильная и сохраняет относительный порядок равных элементов.
5. **Инверсии в массиве**: Для подсчета количества инверсий в массиве (количество пар элементов, в которых более поздний элемент меньше предыдущего) часто используется модификация сортировки слиянием.
6. **Сортировка списков с неизвестной длиной**: Когда длина массива неизвестна или он представлен потоком данных, сортировка слиянием может быть адаптирована для работы в таких условиях.
7. **Графический пользовательский интерфейс**: В графических интерфейсах, где элементы, такие как строки таблицы, должны быть отсортированы, 
сортировка слиянием может обеспечить эффективную сортировку в фоновом режиме или на отдельном потоке.

